<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pac-Bron: King of the Court</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <!-- Firebase (Local) -->
    <script src="firebase-app-compat.js"></script>
    <script src="firebase-firestore-compat.js"></script>
    <script src="firebase-config.js"></script>
    <style>
        :root {
            --bg-color: #121212;
            --lakers-gold: #fdb927;
            --lakers-purple: #552583;
            --floor-dark: #1a1a1a;
            --floor-light: #222;
        }

        body {
            background-color: var(--bg-color);
            color: white;
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            touch-action: none;
        }

        #ui-container {
            width: 100%;
            max-width: 800px;
            display: flex;
            justify-content: space-between;
            padding: 5px 10px;
            box-sizing: border-box;
            z-index: 5;
            height: 40px; /* Compact header */
        }

        .stat-box {
            background: rgba(85, 37, 131, 0.3);
            border: 2px solid var(--lakers-gold);
            padding: 8px 18px;
            border-radius: 6px;
            min-width: 120px;
            min-height: 38px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-shadow: 2px 2px #000;
        }

        .label { color: var(--lakers-gold); font-size: 13px; margin-bottom: 2px; display: block; }
        .value { font-size: 20px; word-break: break-all; }

        #game-wrapper {
            position: relative;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            border: 4px solid var(--lakers-purple);
            background: #000;
            margin: auto; /* Vertically center */
        }

        canvas { display: block; }

        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 20; text-align: center;
        }

        h1 {
            color: var(--lakers-gold);
            text-shadow: 4px 4px var(--lakers-purple);
            font-size: clamp(20px, 5vw, 40px);
            margin-bottom: 10px;
        }

        p { font-size: clamp(10px, 3vw, 14px); color: #ccc; max-width: 80%; line-height: 1.5; }

        button {
            background: var(--lakers-purple);
            color: #fff;
            border: 2px solid var(--lakers-gold);
            padding: 15px 30px;
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(12px, 4vw, 16px);
            cursor: pointer;
            margin-top: 20px;
        }
        button:active { transform: scale(0.95); background: var(--lakers-gold); color: #000; }

        /* --- MOBILE D-PAD (Bottom Right) --- */
        #d-pad {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            z-index: 100;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 8px;
            pointer-events: none;
        }

        @media (hover: none) and (pointer: coarse) {
            #d-pad { display: grid !important; }
            #ui-container { padding: 2px 5px; }
        }

        /* Responsive canvas for mobile/tablet */
        @media (max-width: 900px) {
            #game-wrapper { max-width: 100vw; }
            canvas { width: 100vw !important; height: auto !important; }
        }

        .d-btn {
            background: rgba(85, 37, 131, 0.5); /* More transparent */
            border: 2px solid rgba(253, 185, 39, 0.5);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            pointer-events: auto;
            touch-action: manipulation;
            user-select: none;
            cursor: pointer;
            backdrop-filter: blur(2px);
        }

        .d-btn:active { background: var(--lakers-gold); color: black; opacity: 1; }

        #btn-up { grid-column: 2; grid-row: 1; }
        #btn-left { grid-column: 1; grid-row: 2; }
        #btn-down { grid-column: 2; grid-row: 2; }
        #btn-right { grid-column: 3; grid-row: 2; }

        @media (hover: none) and (pointer: coarse) {
            #d-pad { display: grid; }
            #ui-container { padding: 2px 5px; }
        }

    </style>
</head>
<body>

    <div id="ui-container">
        <div class="stat-box">
            <span class="label">SCORE</span>
            <span class="value" id="score">0</span>
        </div>
        <div class="stat-box">
            <span class="label">HIGH SCORE</span>
            <span class="value" id="high-score">0</span>
        </div>
        <button id="pause-btn" style="display:none; background:var(--lakers-gold); color:var(--lakers-purple); border:none; border-radius:6px; font-family:'Press Start 2P',cursive; font-size:14px; padding:6px 16px; margin-left:10px;">PAUSE</button>
    </div>

    <div id="game-wrapper">
        <canvas id="gameCanvas"></canvas>
        <div id="overlay">
            <h1>PAC-BRON</h1>
            <p style="color:var(--lakers-gold); font-size: 0.8em; margin-top:5px;">Collect basketballs to score.</p>
            <button id="start-btn">TIP OFF</button>
            <div id="controls-hint" style="margin-top:20px; font-size:10px; color:#666;">ARROWS TO MOVE</div>
            <a href="pacbron-info.html" style="margin-top:20px; display:block;">
                <button style="background:var(--lakers-gold); color:var(--lakers-purple); border:none; border-radius:6px; font-family:'Press Start 2P',cursive; font-size:12px; padding:8px 20px; cursor:pointer;">üè† BACK</button>
            </a>
        </div>
        <div id="pause-menu" style="display:none; position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:30; align-items:center; justify-content:center; flex-direction:column; text-align:center;">
            <h1 style="color:var(--lakers-gold); text-shadow:4px 4px var(--lakers-purple);">PAUSED</h1>
            <p style="color:#fff; font-size:16px;">Press <b>P</b> or <b>ESC</b> or tap to resume</p>
            <button id="resume-btn" style="margin-top:20px; background:var(--lakers-gold); color:var(--lakers-purple); border:none; border-radius:6px; font-family:'Press Start 2P',cursive; font-size:16px; padding:10px 30px;">RESUME</button>
        </div>
    </div>

    <div id="d-pad">
        <div class="d-btn" id="btn-up">‚ñ≤</div>
        <div class="d-btn" id="btn-left">‚óÄ</div>
        <div class="d-btn" id="btn-down">‚ñº</div>
        <div class="d-btn" id="btn-right">‚ñ∂</div>
    </div>

    <script>
        // --- Game Config ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('high-score');
        const overlay = document.getElementById('overlay');
        const startBtn = document.getElementById('start-btn');
        
        // Audio
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        // Constants
        let TILE_SIZE = 25; 
        const MAP_WIDTH_TILES = 41; 
        const MAP_HEIGHT_TILES = 22; 
        
        const C_PURPLE = '#552583';
        const C_GOLD = '#fdb927';
        const C_SKIN = '#6d4c41'; 
        const C_BEARD = '#1a1a1a';
        const C_BALL = '#ff6b00';
        const C_FLOOR_1 = '#262626';
        const C_FLOOR_2 = '#2a2a2a';

        // Ghost AI Constants
        const MODE_SWITCH_INTERVAL = 400; // frames (~7 seconds at 60fps)
        const AMBUSH_TILES_AHEAD = 4;
        const PATROL_DISTANCE_THRESHOLD = 8; // in tiles

            const baseMap = [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,0,1],
                [1,3,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1,3,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,3,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,0,1],
                [1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],
                [1,1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1],
                [1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1],
                [1,1,1,1,1,0,1,0,1,9,9,9,1,0,1,0,1,0,1,9,9,9,1,0,1,0,1,0,1,9,9,9,1,0,1,0,1,1,1,1,1],
                [0,0,0,0,0,0,0,0,1,2,2,2,1,0,0,0,0,0,1,2,2,2,1,0,0,0,0,0,1,2,2,2,1,0,0,0,0,0,0,0,0],
                [1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1],
                [1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1],
                [1,1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1],
                [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1],
                [1,3,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,3,1],
                [1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1,1],
                [1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1],
                [1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            ];

        let map = [];
        let score = 0;
        let highScore = localStorage.getItem('pacbron_hs') || 0;
        highScoreEl.innerText = highScore;
        let gameActive = false;
        let animationFrameId;
        let paused = false;

        function playTone(freq, type, duration) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        function resizeGame() {
            const maxWidth = window.innerWidth;
            const mobilePadHeight = (window.matchMedia("(hover: none) and (pointer: coarse)").matches) ? 10 : 0; // minimal buffer
            const maxHeight = window.innerHeight - 50 - mobilePadHeight;

            const tileW = Math.floor(maxWidth / MAP_WIDTH_TILES);
            const tileH = Math.floor(maxHeight / baseMap.length);
            
            TILE_SIZE = Math.min(tileW, tileH);
            
            if (window.innerWidth > 800 && TILE_SIZE > 35) TILE_SIZE = 35;

            canvas.width = MAP_WIDTH_TILES * TILE_SIZE;
            canvas.height = baseMap.length * TILE_SIZE;

            if (!gameActive && player) draw();
        }
        window.addEventListener('resize', resizeGame);

        class Entity {
            constructor(c, r) {
                this.x = c * TILE_SIZE + TILE_SIZE/2;
                this.y = r * TILE_SIZE + TILE_SIZE/2;
                this.dir = {x:0, y:0};
                this.nextDir = {x:0, y:0};
                this.speed = TILE_SIZE / 8; 
                this.radius = TILE_SIZE * 0.45; 
            }
            getCol() { return Math.floor(this.x / TILE_SIZE); }
            getRow() { return Math.floor(this.y / TILE_SIZE); }
            canMove(dx, dy) {
                const c = this.getCol() + dx;
                const r = this.getRow() + dy;
                if (r < 0 || r >= map.length || c < 0 || c >= map[0].length) return false;
                return map[r][c] !== 1;
            }
            move() {
                const centerX = this.getCol() * TILE_SIZE + TILE_SIZE/2;
                const centerY = this.getRow() * TILE_SIZE + TILE_SIZE/2;
                const dist = Math.sqrt((this.x-centerX)**2 + (this.y-centerY)**2);
                if (dist < this.speed) {
                    this.x = centerX;
                    this.y = centerY;
                    if (this.nextDir.x !== 0 || this.nextDir.y !== 0) {
                        if (this.canMove(this.nextDir.x, this.nextDir.y)) {
                            this.dir = {...this.nextDir};
                            this.nextDir = {x:0, y:0};
                        }
                    }
                    if (!this.canMove(this.dir.x, this.dir.y)) {
                        this.dir = {x:0, y:0};
                    }
                }
                // Tunnel warp logic (horizontal only, like classic Pac-Man)
                let nextX = this.x + this.dir.x * this.speed;
                let nextY = this.y + this.dir.y * this.speed;
                const col = this.getCol();
                const row = this.getRow();
                // If at left edge and moving left, warp to right edge tunnel
                if (col === 0 && this.dir.x === -1 && map[row][col] !== 1) {
                    nextX = (map[0].length - 1) * TILE_SIZE + TILE_SIZE/2;
                }
                // If at right edge and moving right, warp to left edge tunnel
                if (col === map[0].length - 1 && this.dir.x === 1 && map[row][col] !== 1) {
                    nextX = TILE_SIZE/2;
                }
                this.x = nextX;
                this.y = nextY;
            }
        }

        class PacBron extends Entity {
            constructor(c, r) { super(c, r); }
            update() {
                this.move();
                const c = this.getCol();
                const r = this.getRow();
                let scoreChanged = false;
                if (map[r][c] === 0) {
                    map[r][c] = 2;
                    score += 10;
                    playTone(200, 'triangle', 0.05);
                    scoreChanged = true;
                } else if (map[r][c] === 3) {
                    map[r][c] = 2;
                    score += 50;
                    playTone(400, 'square', 0.2);
                    activatePower();
                    scoreChanged = true;
                }
                if (scoreChanged) {
                    scoreEl.innerText = score;
                }
                if (score >= highScore) {
                    highScore = score;
                    highScoreEl.innerText = highScore;
                    localStorage.setItem('pacbron_hs', highScore);
                }
            }
            draw(ctx) {
                const r = this.radius;
                ctx.save();
                ctx.translate(this.x, this.y);
                if (this.dir.x < 0) ctx.scale(-1, 1);
                ctx.fillStyle = C_GOLD;
                ctx.beginPath();
                ctx.arc(0, r * 0.8, r, Math.PI, 0); 
                ctx.fill();
                ctx.strokeStyle = C_PURPLE;
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = C_SKIN;
                ctx.beginPath();
                ctx.arc(0, -r * 0.1, r * 0.75, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = C_PURPLE;
                ctx.fillRect(-r*0.7, -r*0.6, r*1.4, r*0.35);
                ctx.fillStyle = C_GOLD; 
                ctx.fillRect(-2, -r*0.55, 4, 3);
                ctx.fillStyle = C_BEARD;
                ctx.beginPath();
                ctx.arc(0, -r*0.1, r*0.75, 0.2 * Math.PI, 0.8 * Math.PI); 
                ctx.lineTo(0, r * 0.2);
                ctx.fill();
                ctx.restore();
            }
        }

        class HoopGhost extends Entity {
            constructor(c, r, color, delay, personality) {
                super(c, r);
                this.color = color;
                this.personality = personality; // 'aggressive', 'ambush', 'random', 'patrol'
                this.scared = false;
                this.active = false;
                this.speed = TILE_SIZE / 10;
                this.mode = 'scatter'; // 'scatter' or 'chase'
                this.modeTimer = 0;
                this.scatterTarget = this.getScatterTarget();
                this.spawnPoint = {x: c, y: r};
                this.exitingSpawn = true;
                setTimeout(() => { 
                    this.active = true; 
                    if (this.dir.x === 0 && this.dir.y === 0) {
                        this.dir = {x:0, y:-1}; // Default direction: up (to exit spawn)
                    }
                }, delay);
            }

            getScatterTarget() {
                // Each ghost has a corner to scatter to (calculated from map dimensions)
                const cornerMargin = 2;
                const corners = [
                    {x: cornerMargin, y: cornerMargin},   // Top-left
                    {x: MAP_WIDTH_TILES - cornerMargin - 1, y: cornerMargin},  // Top-right
                    {x: cornerMargin, y: MAP_HEIGHT_TILES - cornerMargin - 1},  // Bottom-left
                    {x: MAP_WIDTH_TILES - cornerMargin - 1, y: MAP_HEIGHT_TILES - cornerMargin - 1}  // Bottom-right
                ];
                return corners[Math.floor(Math.random() * corners.length)];
            }

            isInSpawn() {
                const tile = map[this.getRow()] && map[this.getRow()][this.getCol()];
                return tile === 9;
            }

            getTargetTile() {
                if (!player) return {x: 20, y: 11};

                if (this.scared) {
                    // When scared, target away from player
                    const dx = this.x - player.x;
                    const dy = this.y - player.y;
                    const targetX = Math.floor((this.x + dx * 2) / TILE_SIZE);
                    const targetY = Math.floor((this.y + dy * 2) / TILE_SIZE);
                    return {x: targetX, y: targetY};
                }

                if (this.exitingSpawn) {
                    // Target just outside spawn (upward)
                    const currentRow = this.getRow();
                    for (let r = currentRow - 1; r >= 0; r--) {
                        const tile = map[r] && map[r][this.getCol()];
                        if (tile !== undefined && tile !== 9 && tile !== 1) {
                            return {x: this.getCol(), y: r};
                        }
                    }
                }

                if (this.mode === 'scatter') {
                    return this.scatterTarget;
                }

                // Chase mode - different personalities
                const playerCol = player.getCol();
                const playerRow = player.getRow();

                switch(this.personality) {
                    case 'aggressive':
                        // Direct pursuit
                        return {x: playerCol, y: playerRow};
                    
                    case 'ambush':
                        // Target tiles ahead of player
                        const aheadX = playerCol + (player.dir.x * AMBUSH_TILES_AHEAD);
                        const aheadY = playerRow + (player.dir.y * AMBUSH_TILES_AHEAD);
                        return {x: aheadX, y: aheadY};
                    
                    case 'patrol':
                        // Target based on distance - closer or further depending on distance threshold
                        const dist = Math.hypot(this.x - player.x, this.y - player.y);
                        if (dist < TILE_SIZE * PATROL_DISTANCE_THRESHOLD) {
                            return {x: playerCol, y: playerRow};
                        } else {
                            return this.scatterTarget;
                        }
                    
                    case 'random':
                        // Mix of random and player tracking
                        if (Math.random() < 0.4) {
                            return {
                                x: Math.floor(Math.random() * map[0].length),
                                y: Math.floor(Math.random() * map.length)
                            };
                        }
                        return {x: playerCol, y: playerRow};
                    
                    default:
                        return {x: playerCol, y: playerRow};
                }
            }

            getBestDirection(target) {
                const dirs = [
                    {x:0, y:-1}, // up
                    {x:0, y:1},  // down
                    {x:-1, y:0}, // left
                    {x:1, y:0}   // right
                ];

                let bestDir = null;
                let bestDist = Infinity;
                const reverseDir = {x: -this.dir.x, y: -this.dir.y};

                for (let d of dirs) {
                    // Don't reverse unless necessary
                    if (d.x === reverseDir.x && d.y === reverseDir.y && bestDir !== null) continue;
                    
                    if (this.canMove(d.x, d.y)) {
                        const nextCol = this.getCol() + d.x;
                        const nextRow = this.getRow() + d.y;
                        
                        // Calculate distance to target
                        const dist = Math.abs(nextCol - target.x) + Math.abs(nextRow - target.y);
                        
                        if (dist < bestDist) {
                            bestDist = dist;
                            bestDir = d;
                        }
                    }
                }

                // If no valid move found (shouldn't happen), allow reverse
                if (bestDir === null) {
                    for (let d of dirs) {
                        if (this.canMove(d.x, d.y)) {
                            return d;
                        }
                    }
                }

                return bestDir || this.dir;
            }

            update() {
                if (!this.active) return;

                // Update mode timer
                this.modeTimer++;
                if (this.modeTimer > MODE_SWITCH_INTERVAL && !this.scared) {
                    this.mode = this.mode === 'chase' ? 'scatter' : 'chase';
                    this.modeTimer = 0;
                }

                // Check if still in spawn
                if (this.exitingSpawn && !this.isInSpawn()) {
                    this.exitingSpawn = false;
                }

                const centerX = this.getCol() * TILE_SIZE + TILE_SIZE/2;
                const centerY = this.getRow() * TILE_SIZE + TILE_SIZE/2;
                const dist = Math.sqrt((this.x-centerX)**2 + (this.y-centerY)**2);

                // Make decision at tile center
                if (dist < this.speed) {
                    this.x = centerX;
                    this.y = centerY;

                    const target = this.getTargetTile();
                    const newDir = this.getBestDirection(target);
                    
                    if (newDir) {
                        this.dir = newDir;
                    }
                }

                // Move
                const moveSpeed = this.scared ? this.speed * 0.5 : this.speed;
                this.x += this.dir.x * moveSpeed;
                this.y += this.dir.y * moveSpeed;
            }
            draw(ctx) {
                const r = this.radius;
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // SCARED LOGIC
                if (this.scared) {
                    // Flash when timer is low (last 120 frames approx 2 seconds)
                    if (powerTimer < 120 && Math.floor(Date.now() / 100) % 2 === 0) {
                         // Flash White
                        ctx.fillStyle = '#fff';
                    } else {
                        // Blue
                        ctx.fillStyle = '#2196f3';
                    }
                    
                    ctx.font = `${Math.floor(r)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('3-0', 0, 0); 
                    ctx.restore();
                    return;
                }

                ctx.fillStyle = 'white';
                ctx.fillRect(-r, -r, r*2, r*1.2);
                ctx.strokeStyle = '#ccc';
                ctx.strokeRect(-r, -r, r*2, r*1.2);
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.strokeRect(-r*0.4, -r*0.4, r*0.8, r*0.5);
                ctx.strokeStyle = 'orange';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-r*0.5, r*0.2);
                ctx.lineTo(r*0.5, r*0.2);
                ctx.stroke();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(-r*0.5, r*0.2);
                ctx.lineTo(-r*0.3, r*0.8);
                ctx.lineTo(0, r*0.9);
                ctx.lineTo(r*0.3, r*0.8);
                ctx.lineTo(r*0.5, r*0.2);
                ctx.stroke();
                ctx.restore();
            }
        }

        let player;
        let ghosts = [];
        let powerTimer = 0;
        let ghostCombo = 0;

        function init() {
            if (window.matchMedia("(hover: none) and (pointer: coarse)").matches) {
                document.getElementById('controls-hint').innerText = "CONTROLS BOTTOM RIGHT";
            }
            resizeGame();
            // Deep copy baseMap
            map = baseMap.map(row => [...row]);
            // --- Randomize pellet and power pellet placement ---
            // Collect all possible pellet positions (not wall, not spawn, not tunnel, not player start)
            let pelletPositions = [];
            let powerPelletPositions = [];
            for (let r = 0; r < map.length; r++) {
                for (let c = 0; c < map[0].length; c++) {
                    if (map[r][c] === 0) pelletPositions.push([r, c]);
                    if (map[r][c] === 3) powerPelletPositions.push([r, c]);
                }
            }
            // Shuffle pellet positions
            function shuffle(arr) {
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
            }
            shuffle(pelletPositions);
            shuffle(powerPelletPositions);
            // Clear all pellets from map
            for (let r = 0; r < map.length; r++) {
                for (let c = 0; c < map[0].length; c++) {
                    if (map[r][c] === 0 || map[r][c] === 3) map[r][c] = 2;
                }
            }
            // Place pellets (0) and power pellets (3) randomly
            // Use same count as in baseMap
            for (let i = 0; i < pelletPositions.length; i++) {
                const [r, c] = pelletPositions[i];
                map[r][c] = 0;
            }
            for (let i = 0; i < powerPelletPositions.length; i++) {
                const [r, c] = powerPelletPositions[i];
                map[r][c] = 3;
            }
            score = 0;
            scoreEl.innerText = 0;
            player = new PacBron(10, 15);
            player.nextDir = {x:1, y:0};
            // Find all spawn boxes (tile value 9) and spawn ghosts with unique personalities
            const ghostColors = ['#ff0000', '#00ff00', '#0000ff', '#ffb347', '#ff69b4', '#00ffff', '#ff00ff', '#a52a2a', '#8a2be2', '#228b22', '#ffd700', '#ff1493'];
            const ghostPersonalities = ['aggressive', 'ambush', 'patrol', 'random'];
            let ghostIndex = 0;
            ghosts = [];
            for (let r = 0; r < map.length; r++) {
                for (let c = 0; c < map[0].length; c++) {
                    if (map[r][c] === 9) {
                        ghosts.push(new HoopGhost(
                            c, r,
                            ghostColors[ghostIndex % ghostColors.length],
                            ghostIndex * 2000,
                            ghostPersonalities[ghostIndex % ghostPersonalities.length]
                        ));
                        ghostIndex++;
                    }
                }
            }
            gameActive = true;
            loop();
        }

        function activatePower() {
            // REDUCED TIMER: 350 frames is approx 6 seconds at 60fps
            powerTimer = 350; 
            ghosts.forEach(g => g.scared = true);
            ghostCombo = 0;
        }

        function checkCollisions() {
            for (let g of ghosts) {
                const dist = Math.hypot(player.x - g.x, player.y - g.y);
                if (dist < TILE_SIZE * 0.8) {
                    if (g.scared) {
                        g.x = 10 * TILE_SIZE + TILE_SIZE/2;
                        g.y = 10 * TILE_SIZE + TILE_SIZE/2;
                        g.scared = false;
                        // Combo scoring: 200, 400, 800, 1600, ...
                        ghostCombo = (ghostCombo || 0) + 1;
                        let comboScore = 200 * Math.pow(2, ghostCombo - 1);
                        score += comboScore;
                        scoreEl.innerText = score;
                        playTone(150, 'sawtooth', 0.1);
                    } else {
                        gameActive = false;
                        overlay.style.display = 'flex';
                        overlay.querySelector('h1').innerText = "FOUL OUT!";
                        overlay.querySelector('p').innerText = "FINAL SCORE: " + score;
                        startBtn.innerText = "REMATCH";
                        // Submit score to leaderboard
                        submitScoreToLeaderboard('PacBron', score, 'normal');
                    }
                }
            }
            let hasPellets = false;
            for(let r=0; r<map.length; r++) {
                for(let c=0; c<map[0].length; c++) {
                    if (map[r][c] === 0 || map[r][c] === 3) hasPellets = true;
                }
            }
            if (!hasPellets) {
                gameActive = false;
                overlay.style.display = 'flex';
                overlay.querySelector('h1').innerText = "CHAMPION!";
                overlay.querySelector('p').innerText = "COURT CLEARED";
                // Submit score to leaderboard
                submitScoreToLeaderboard('PacBron', score, 'normal');
            }
        }

        function draw() {
            ctx.fillStyle = C_FLOOR_1;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = C_FLOOR_2;
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let x=0; x<canvas.width; x+=TILE_SIZE) { ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); }
            for(let y=0; y<canvas.height; y+=TILE_SIZE) { ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); }
            ctx.stroke();

            for (let r = 0; r < map.length; r++) {
                for (let c = 0; c < map[0].length; c++) {
                    const tile = map[r][c];
                    const x = c * TILE_SIZE;
                    const y = r * TILE_SIZE;
                    const cx = x + TILE_SIZE/2;
                    const cy = y + TILE_SIZE/2;

                    if (tile === 1) {
                        ctx.fillStyle = '#000';
                        ctx.fillRect(x,y,TILE_SIZE,TILE_SIZE);
                        ctx.strokeStyle = C_PURPLE;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x+2,y+2,TILE_SIZE-4, TILE_SIZE-4);
                    } else if (tile === 0) {
                        ctx.fillStyle = C_BALL;
                        ctx.beginPath();
                        ctx.arc(cx, cy, TILE_SIZE * 0.25, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(cx, cy - TILE_SIZE*0.25);
                        ctx.lineTo(cx, cy + TILE_SIZE*0.25);
                        ctx.stroke();
                    } else if (tile === 3) {
                        if (Math.floor(Date.now()/200)%2===0) {
                            ctx.fillStyle = '#ffd700';
                            ctx.beginPath();
                            ctx.arc(cx, cy, TILE_SIZE * 0.4, 0, Math.PI*2);
                            ctx.fill();
                            ctx.shadowColor = '#ffd700';
                            ctx.shadowBlur = 10;
                            ctx.stroke();
                            ctx.shadowBlur = 0;
                        }
                    } else if (tile === 9) {
                        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                        ctx.beginPath();
                        ctx.moveTo(x, cy);
                        ctx.lineTo(x+TILE_SIZE, cy);
                        ctx.stroke();
                    }
                }
            }
            if (player) player.draw(ctx);
            ghosts.forEach(g => g.draw(ctx));
        }

        function loop() {
            if (!gameActive || paused) return;
            if (powerTimer > 0) {
                powerTimer--;
                if (powerTimer === 0) {
                    ghosts.forEach(g => g.scared = false);
                    ghostCombo = 0;
                }
            }
            player.update();
            ghosts.forEach(g => g.update());
            checkCollisions();
            draw();
            animationFrameId = requestAnimationFrame(loop);
        }
        // --- Pause Menu Logic ---
        const pauseMenu = document.getElementById('pause-menu');
        const pauseBtn = document.getElementById('pause-btn');
        const resumeBtn = document.getElementById('resume-btn');
        function setPaused(state) {
            paused = state;
            if (paused) {
                pauseMenu.style.display = 'flex';
            } else {
                pauseMenu.style.display = 'none';
                if (gameActive) loop();
            }
        }

        // Show pause button on mobile/tablet
        function isTouchDevice() {
            return window.matchMedia('(hover: none) and (pointer: coarse)').matches;
        }
        function updatePauseBtnVisibility() {
            if (isTouchDevice()) {
                pauseBtn.style.display = 'inline-block';
            } else {
                pauseBtn.style.display = 'none';
            }
        }
        updatePauseBtnVisibility();
        window.addEventListener('resize', updatePauseBtnVisibility);

        pauseBtn.addEventListener('click', () => {
            if (gameActive && !paused) setPaused(true);
        });
        if (resumeBtn) resumeBtn.addEventListener('click', () => setPaused(false));
        if (pauseMenu) pauseMenu.addEventListener('touchstart', () => { if (paused) setPaused(false); });

        window.addEventListener('keydown', e => {
            if (e.key === 'p' || e.key === 'P' || e.key === 'Escape') {
                if (gameActive) {
                    setPaused(!paused);
                }
            }
        });

        window.addEventListener('keydown', e => {
            if (!gameActive) return;
            switch(e.key) {
                case 'ArrowUp': player.nextDir = {x:0, y:-1}; break;
                case 'ArrowDown': player.nextDir = {x:0, y:1}; break;
                case 'ArrowLeft': player.nextDir = {x:-1, y:0}; break;
                case 'ArrowRight': player.nextDir = {x:1, y:0}; break;
            }
        });

        const setupBtn = (id, dx, dy) => {
            const btn = document.getElementById(id);
            const handler = (e) => {
                if(e.cancelable) e.preventDefault();
                if(gameActive && player) player.nextDir = {x:dx, y:dy};
            };
            btn.addEventListener('touchstart', handler, {passive:false});
            btn.addEventListener('mousedown', handler); 
        };
        setupBtn('btn-up', 0, -1);
        setupBtn('btn-down', 0, 1);
        setupBtn('btn-left', -1, 0);
        setupBtn('btn-right', 1, 0);

        let touchStartX = 0;
        let touchStartY = 0;
        canvas.addEventListener('touchstart', e => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, {passive: false});
        canvas.addEventListener('touchmove', e => {
            if (!gameActive) return;
            e.preventDefault();
            const x = e.touches[0].clientX;
            const y = e.touches[0].clientY;
            const dx = x - touchStartX;
            const dy = y - touchStartY;
            const threshold = 15; 
            if (Math.abs(dx) > Math.abs(dy)) {
                if (Math.abs(dx) > threshold) {
                    player.nextDir = {x: dx > 0 ? 1 : -1, y: 0};
                    touchStartX = x; touchStartY = y;
                }
            } else {
                if (Math.abs(dy) > threshold) {
                    player.nextDir = {x: 0, y: dy > 0 ? 1 : -1};
                    touchStartX = x; touchStartY = y;
                }
            }
        }, {passive: false});

        startBtn.addEventListener('click', () => {
            overlay.style.display = 'none';
            if (!player || !gameActive) init();
        });

        setTimeout(() => {
            resizeGame();
            init();
            gameActive = false;
            draw();
        }, 100);

    </script>
</body>
</html>
